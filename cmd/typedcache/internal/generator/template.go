package generator

// typedCacheTemplate holds the base template for a typed cache
const typedCacheTemplate = `
// Code generated by github.com/Hartimer/loadingcache/cmd/typedcache, DO NOT EDIT.
package {{.Package}}

type {{.Name}} interface {
	Get(key {{.KeyType}}) ({{.ValueType}}, error)
	Put(key {{.KeyType}}, value {{.ValueType}})
	Invalidate(key {{.KeyType}}, keys ...{{.KeyType}})
	InvalidateAll()
}

type {{.Name}}Options struct {
	Clock            clock.Clock
	ExpireAfterWrite time.Duration
	ExpireAfterRead  time.Duration
	Load             LoadFunc
	MaxSize          int32
	RemovalListeners []RemovalListener
	ShardCount       int
	HashCodeFunc     func(key {{.KeyType}}) int
}

func (c {{.Name}}Options) expiresAfterRead() bool {
	return c.ExpireAfterRead > 0
}

func (c {{.Name}}Options) expiresAfterWrite() bool {
	return c.ExpireAfterWrite > 0
}

type LoadFunc func({{.KeyType}}) ({{.ValueType}}, error)

type RemovalNotification struct {
	Key    {{.KeyType}}
	Value  {{.ValueType}}
	Reason loadingcache.RemovalReason
}

type RemovalListener func(RemovalNotification)

type internalImplementation struct {
	genericCache loadingcache.Cache
}

func New{{.Name}}(options {{.Name}}Options) {{.Name}} {
	finalOptions := loadingcache.CacheOptions{
		Clock:            options.Clock,
		ExpireAfterWrite: options.ExpireAfterWrite,
		ExpireAfterRead:  options.ExpireAfterRead,
		MaxSize:          options.MaxSize,
		RemovalListeners: make([]loadingcache.RemovalListener, len(options.RemovalListeners)),
		ShardCount:       options.ShardCount,
	}

	if options.Load != nil {
		finalOptions.Load = func(key interface{}) (interface{}, error) {
			return options.Load(key.({{.KeyType}}))
		}
	}

	if options.HashCodeFunc != nil {
		finalOptions.HashCodeFunc = func(key interface{}) int {
			return options.HashCodeFunc(key.({{.KeyType}}))
		}
	}

	for i := range options.RemovalListeners {
		removalListener := options.RemovalListeners[i]
		finalOptions.RemovalListeners[i] = func(notification loadingcache.RemovalNotification) {
			typedNotification := RemovalNotification{
				Key:    notification.Key.({{.KeyType}}),
				Value:  notification.Value.({{.ValueType}}),
				Reason: notification.Reason,
			}
			removalListener(typedNotification)
		}
	}

	return &internalImplementation{
		genericCache: loadingcache.New(finalOptions),
	}
}

func (i *internalImplementation) Get(key {{.KeyType}}) ({{.ValueType}}, error) {
	val, err := i.genericCache.Get(key)
	if err != nil {
		return 0, err
	}
	typedVal, ok := val.({{.ValueType}})
	if !ok {
		panic(fmt.Sprintf("Type mismatch, expected %T got %T", typedVal, val))
	}
	return typedVal, nil
}

func (i *internalImplementation) Put(key {{.KeyType}}, value {{.ValueType}}) {
	i.genericCache.Put(key, value)
}

func (i *internalImplementation) Invalidate(key {{.KeyType}}, keys ...{{.KeyType}}) {
	genericKeys := make([]interface{}, len(keys))
	for i, k := range keys {
		genericKeys[i] = k
	}
	i.genericCache.Invalidate(key, genericKeys...)
}

func (i *internalImplementation) InvalidateAll() {
	i.genericCache.InvalidateAll()
}
`
