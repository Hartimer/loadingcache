package generator_test

const expectedOutput = `// Code generated by github.com/Hartimer/loadingcache/cmd/typedcache, DO NOT EDIT.
package generator

import (
	"fmt"
	"time"

	"github.com/Hartimer/loadingcache"
	"github.com/benbjohnson/clock"
)

type {{.Name}} interface {
	Get(key string) (int64, error)
	Put(key string, value int64)
	Invalidate(key string, keys ...string)
	InvalidateAll()
}

type {{.Name}}Option func({{.Name}})

type LoadFunc func(string) (int64, error)

type RemovalNotification struct {
	Key    string
	Value  int64
	Reason loadingcache.RemovalReason
}

type RemovalListenerFunc func(RemovalNotification)

type internalImplementation struct {
	genericCache loadingcache.Cache
	cacheOptions []loadingcache.CacheOption
}

func Clock(clk clock.Clock) {{.Name}}Option {
	return func(cache {{.Name}}) {
		if g, ok := cache.(*internalImplementation); ok {
			g.cacheOptions = append(g.cacheOptions, loadingcache.Clock(clk))
		}
	}
}

func ExpireAfterWrite(duration time.Duration) {{.Name}}Option {
	return func(cache {{.Name}}) {
		if g, ok := cache.(*internalImplementation); ok {
			g.cacheOptions = append(g.cacheOptions, loadingcache.ExpireAfterWrite(duration))
		}
	}
}

func ExpireAfterRead(duration time.Duration) {{.Name}}Option {
	return func(cache {{.Name}}) {
		if g, ok := cache.(*internalImplementation); ok {
			g.cacheOptions = append(g.cacheOptions, loadingcache.ExpireAfterRead(duration))
		}
	}
}

func Load(f LoadFunc) {{.Name}}Option {
	return func(cache {{.Name}}) {
		if g, ok := cache.(*internalImplementation); ok {
			g.cacheOptions = append(g.cacheOptions, loadingcache.Load(func(key interface{}) (interface{}, error) {
				typedKey, ok := key.(string)
				if !ok {
					return 0, fmt.Errorf("Key expeceted to be a string but got %T", key)
				}
				return f(typedKey)
			}))
		}
	}
}

func MaxSize(maxSize int32) {{.Name}}Option {
	return func(cache {{.Name}}) {
		if g, ok := cache.(*internalImplementation); ok {
			g.cacheOptions = append(g.cacheOptions, loadingcache.MaxSize(maxSize))
		}
	}
}

func RemovalListener(listener RemovalListenerFunc) {{.Name}}Option {
	return func(cache {{.Name}}) {
		if g, ok := cache.(*internalImplementation); ok {
			g.cacheOptions = append(g.cacheOptions, loadingcache.RemovalListener(func(notification loadingcache.RemovalNotification) {
				typedNofication := RemovalNotification{Reason: notification.Reason}
				var ok bool
				typedNofication.Key, ok = notification.Key.(string)
				if !ok {
					panic(fmt.Sprintf("Somehow the key is a %T instead of a string", notification.Key))
				}
				typedNofication.Value, ok = notification.Value.(int64)
				if !ok {
					panic(fmt.Sprintf("Somehow the value is a %T instead of an int64", notification.Value))
				}
				listener(typedNofication)
			}))
		}
	}
}

func NewCache(options ...{{.Name}}Option) {{.Name}} {
	internal := &internalImplementation{}
	for _, option := range options {
		option(internal)
	}

	internal.genericCache = loadingcache.NewGenericCache(internal.cacheOptions...)
	return internal
}

func (i *internalImplementation) Get(key string) (int64, error) {
	val, err := i.genericCache.Get(key)
	if err != nil {
		return 0, err
	}
	typedVal, ok := val.(int64)
	if !ok {
		// TODO type mismatch error
	}
	return typedVal, nil
}

func (i *internalImplementation) Put(key string, value int64) {
	i.genericCache.Put(key, value)
}

func (i *internalImplementation) Invalidate(key string, keys ...string) {
	genericKeys := make([]interface{}, len(keys))
	for i, k := range keys {
		genericKeys[i] = k
	}
	i.genericCache.Invalidate(key, genericKeys...)
}

func (i *internalImplementation) InvalidateAll() {
	i.genericCache.InvalidateAll()
}
`
